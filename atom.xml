<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>迁乔的博客</title>
  
  
  <link href="https://alexuhui.github.io/atom.xml" rel="self"/>
  
  <link href="https://alexuhui.github.io/"/>
  <updated>2022-09-25T14:41:29.389Z</updated>
  <id>https://alexuhui.github.io/</id>
  
  <author>
    <name>迁乔</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>判断圆与矩形相交</title>
    <link href="https://alexuhui.github.io/2022/09/25/math-rect-circle-intersect/"/>
    <id>https://alexuhui.github.io/2022/09/25/math-rect-circle-intersect/</id>
    <published>2022-09-25T09:50:35.000Z</published>
    <updated>2022-09-25T14:41:29.389Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-边和坐标轴平行的矩形和圆相交的情况"><a href="#1-边和坐标轴平行的矩形和圆相交的情况" class="headerlink" title="1.边和坐标轴平行的矩形和圆相交的情况"></a>1.边和坐标轴平行的矩形和圆相交的情况</h3><h4 id="方法1：通过找到相交和相离的边界条件。再推广到一般情况。"><a href="#方法1：通过找到相交和相离的边界条件。再推广到一般情况。" class="headerlink" title="方法1：通过找到相交和相离的边界条件。再推广到一般情况。"></a>方法1：通过找到相交和相离的边界条件。再推广到一般情况。<br></h4><p>这种方法很直觉，很好理解。如下图1：<br><br><img src="/2022/09/25/math-rect-circle-intersect/CircleRectInsert.jpg" alt="图1：圆与矩形关系边界条件"> <br><br>想象一下，有个圆圆的轮子绕着矩形滚一圈，圆心的坐标，是不是就是边界条件？<br><br>那么，假设矩形中心在坐标原点的情况下，<br><br>1、当圆在拐角时的边界： <code>|BG| = r</code>  即  <code>x^2 + y^2 = r^2</code>  那么要相交也就是   <code>x^2 + y^2 &lt; r^2</code> <br><br>拐角必然是离圆心最近的顶点，分别找出离圆心最近的x,y值，即可根据<code>x^2 + y^2 &lt; r^2</code>判断。 <br><br>2、当圆在矩形上方时： <code>|EF| = r</code> 即  <code>y - halfH = r</code>  那么相交就是 <code>y &lt; r + halfH</code> ;  <br><br>显然，当圆在矩形下方时， <code>-y &lt; r + halfH</code>; <br><br>另外，圆在矩形上方&#x2F;下方的充要条件是 <code>- halfW &lt; x &lt; halfW</code> 即  <code>|x| &lt; halfW</code> <br><br>3、当圆在在两侧时，和上下思路一样。<br><br>综上，<br><br>假设矩形中心点rectPos，长宽的一半halfSize，圆心circlePos，半径radius: <br></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs CS"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CheckCircleRectInsert1</span>(<span class="hljs-params">Vector2 rectPos, Vector2 halfSize, Vector2 circlePos, <span class="hljs-built_in">float</span> radius</span>)</span><br>&#123;<br>    <span class="hljs-comment">//条件1 拐角</span><br>    <span class="hljs-built_in">float</span> minx, miny;<br>    <span class="hljs-comment">//找出离圆心最近的顶点的x值</span><br>    minx = Mathf.Min(Mathf.Abs(rectPos.x + halfSize.x - circlePos.x), Mathf.Abs(rectPos.x - halfSize.x - circlePos.x));<br>    <span class="hljs-comment">//找出离圆心最近的顶点的y值</span><br>    miny = Mathf.Min(Mathf.Abs(rectPos.y + halfSize.y - circlePos.y), Mathf.Abs(rectPos.y - halfSize.y - circlePos.y));<br>    <span class="hljs-keyword">if</span> (minx * minx + miny * miny &lt;= radius * radius) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">//条件2 外边  </span><br>    <span class="hljs-built_in">float</span> lenx = Mathf.Abs(rectPos.x - circlePos.x);<br>    <span class="hljs-built_in">float</span> leny = Mathf.Abs(rectPos.y - circlePos.y);<br>    <span class="hljs-keyword">if</span> (lenx &lt; halfSize.x + radius &amp;&amp; leny &lt; halfSize.y)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (leny &lt; halfSize.y + radius &amp;&amp; lenx &lt; halfSize.x)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：<br></h4><p>这种方法比较抽象，可参考<a href="https://www.zhihu.com/question/24251545">知乎答案</a> <br><br>这个方法巧妙地运用了矩形的对称性质。<br><br>其实，如果理解了第一种方法，方法2也就不难理解了。想象一下，类似折纸，由于矩形的对称性，可以把任意位置的圆对称到矩形的右上方（当然，也可能是正上方，正右方，或者中心）。而这个处理过程也很简单，算出矩形中心指向圆心的向量<code>v</code>，只要对<code>x</code>, <code>y</code>取绝对值即可。<br><br>如下图2：<br><br><img src="/2022/09/25/math-rect-circle-intersect/CircleRectInsert2.jpg" alt="图2：圆与矩形关系的向量表示"><br><br>本质上，该方法，也是分三种情况来理解：<br><br>1、当圆在拐角时，向量<code>v - h</code>得到的向量<code>u</code>的模就是顶点到圆心的距离，所以，<code>|u| &lt; r</code>即是相交 <br><br>2、当圆在矩形上方\下方时，边界值也是矩形的宽的一半加上圆的半径。这里可以忽略<code>u</code>的<code>x</code>，那么<code>|u|</code>就是圆心到矩形边的距离了，所以，<code>|u| &lt; r</code>即是相交 <br><br>3、当圆在在两侧时，和上下思路一样。<br><br>综上，方法运用向量把各种情况统一了起来：<br><br>假设矩形中心点rectPos，长宽的一半halfSize，圆心circlePos，半径radius: <br></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CS"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CheckCircleRectInsert2</span>(<span class="hljs-params">Vector2 rectPos, Vector2 halfSize, Vector2 circlePos, <span class="hljs-built_in">float</span> radius</span>)</span><br> &#123;<br>     <span class="hljs-comment">// 第1步：转换至第1象限</span><br>     Vector2 v = <span class="hljs-keyword">new</span> Vector2(Mathf.Abs(rectPos.x - circlePos.x), Mathf.Abs(rectPos.y - circlePos.y));<br>     <span class="hljs-comment">//第2步：求圆心至矩形的最短距离矢量</span><br>     Vector2 u = Vector2.Max(v - halfSize, Vector2.zero);<br>     <span class="hljs-comment">// 第3步：长度平方与半径平方比较</span><br>     <span class="hljs-keyword">return</span> Vector2.Dot(u, u) &lt;= radius * radius;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="2-边和坐标轴不平行的矩形和圆相交的情况"><a href="#2-边和坐标轴不平行的矩形和圆相交的情况" class="headerlink" title="2.边和坐标轴不平行的矩形和圆相交的情况"></a>2.边和坐标轴不平行的矩形和圆相交的情况</h3><p>接下来，看看当矩形可能发生旋转的情况。<br><br>当矩形发生旋转后，一种很自然的想法就是：<br><br>把圆心变换到矩形的局部空间（以矩形中心为原点，坐标轴平行于矩形的边）。<br><br>这样，接着用上面的方法判断就好了。<br><br>变换矩阵的构造就简单上个图，如图3：<br><br>截图来自闫令琪大神的课件：<br><a href="https://www.bilibili.com/video/BV1X7411F744?p=3&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=9ac312e492d54319bc438327ffb04b0c">GAMES101 现代计算机图形学入门</a>  <br><br><img src="/2022/09/25/math-rect-circle-intersect/20220917164345.jpg" alt="图3：二维空间中的旋转矩阵">  <br></p><figure class="highlight plaintext"><figcaption><span>static Matrix3x3 Get2DTRMatrix(Vector2 pos, float rot)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs public">&#123;<br>    var cos = Mathf.Cos(Mathf.Deg2Rad * rot);<br>    var sin = Mathf.Sin(Mathf.Deg2Rad * rot);<br>// 按行构建位移旋转变换矩阵（这里忽略了缩放）<br>    var row0 = new Vector3(cos, -sin, pos.x);<br>    var row1 = new Vector3(sin, cos, pos.y);<br>    var row2 = new Vector3(0, 0, 1);<br>    Matrix3x3 matrix = Matrix3x3.CreateFromRows(row0, row1, row2).Inverse();<br>    return matrix;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>TODO  为什么要求逆才对呢？</code><br></p><p>假设矩形中心点rectPos，长宽的一半halfSize，旋转角度为radius，圆心circlePos，半径radius<br></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs CS"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CheckCircleRectRotInsert</span>(<span class="hljs-params">Vector2 rectPos,  Vector2 halfSize, <span class="hljs-built_in">float</span> rectRot, Vector2 circlePos, <span class="hljs-built_in">float</span> radius</span>)</span><br>&#123;<br>    <span class="hljs-comment">//按行排列3x3矩阵</span><br>    <span class="hljs-keyword">var</span> mat3x3 = Get2DTRMatrix(rectPos, rectRot);<br>    <span class="hljs-comment">// ----------------</span><br>    <span class="hljs-comment">// [row0]            </span><br>    <span class="hljs-comment">// [row1]    点乘    [circlePos, 1] （转置）</span><br>    <span class="hljs-comment">// [0,0,1]</span><br>    <span class="hljs-built_in">float</span> x = mat3x3.V00 * circlePos.x + mat3x3.V01 * circlePos.y + mat3x3.V02;<br>    <span class="hljs-built_in">float</span> y = mat3x3.V10 * circlePos.x + mat3x3.V11 * circlePos.y + mat3x3.V12;<br>    Vector2 circleLocalPos = <span class="hljs-keyword">new</span> Vector2(x,y);<br><br>    <span class="hljs-comment">// 注意这里转到了矩形本地坐标，那矩形中心点就是(0,0)了</span><br>    <span class="hljs-keyword">return</span> CheckCircleRectInsert1(Vector2.zero, halfSize, circleLocalPos, radius);<br>    <span class="hljs-comment">//return CheckCircleRectInsert2(Vector2.zero, halfSize, circleLocalPos, radius);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而对于方法2，还有另一种方法。<br><br>因为向量有和位置无关的天然优势，所以只考虑旋转就好了。既然矩形旋转了，就想办法把它旋回去，也就是反向旋转相同的角度。把矩形中心指向圆心的向量也跟着旋转，就转换成了未旋转时的情况。如下图4：<br><br><img src="/2022/09/25/math-rect-circle-intersect/CircleRectInsertRot.jpg" alt="图4：矩形指向圆心的向量伴随矩形一起旋转"><br></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CS"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CheckCircleRectRotInsert2</span>(<span class="hljs-params">Vector2 rectPos, Vector2 halfSize, <span class="hljs-built_in">float</span> rectRot, Vector2 circlePos, <span class="hljs-built_in">float</span> radius</span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> dir = circlePos - rectPos;<br>    dir = Quaternion.AngleAxis(-rectRot, Vector3.forward) * dir;<br>    <span class="hljs-keyword">var</span> v = Vector2.Max(dir, -dir);<br>    <span class="hljs-keyword">var</span> u = Vector2.Max(v - halfSize, Vector3.zero);<br>    <span class="hljs-keyword">return</span> Vector2.Dot(u, u) &lt;= radius * radius;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：旋转的时候，分清是基于哪条轴做旋转。拎不清的话，很容易懵逼。<br><br>Unity使用的世界是左手坐标系，如下图5：<br><br>在绕Z轴旋转时，是逆时针的，而绕X、Y轴旋转时是顺时针的。<br><br><img src="/2022/09/25/math-rect-circle-intersect/left-half_coordinate_system.jpg" alt="图5：左手系的旋转"><br></p><p><a href="https://github.com/alexuhui/algorithm">相关工程github</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-边和坐标轴平行的矩形和圆相交的情况&quot;&gt;&lt;a href=&quot;#1-边和坐标轴平行的矩形和圆相交的情况&quot; class=&quot;headerlink&quot; title=&quot;1.边和坐标轴平行的矩形和圆相交的情况&quot;&gt;&lt;/a&gt;1.边和坐标轴平行的矩形和圆相交的情况&lt;/h3&gt;&lt;h4 i</summary>
      
    
    
    
    <category term="数学" scheme="https://alexuhui.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="几何" scheme="https://alexuhui.github.io/categories/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/"/>
    
    
    <category term="数学" scheme="https://alexuhui.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="几何" scheme="https://alexuhui.github.io/tags/%E5%87%A0%E4%BD%95/"/>
    
    <category term="矩形" scheme="https://alexuhui.github.io/tags/%E7%9F%A9%E5%BD%A2/"/>
    
    <category term="圆" scheme="https://alexuhui.github.io/tags/%E5%9C%86/"/>
    
    <category term="相交" scheme="https://alexuhui.github.io/tags/%E7%9B%B8%E4%BA%A4/"/>
    
  </entry>
  
</feed>
